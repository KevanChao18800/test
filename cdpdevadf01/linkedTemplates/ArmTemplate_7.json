{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "cdpdevadf01"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/DS_LocalSQL')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "LS_LOCALSQL",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "ProductKey",
						"type": "int",
						"precision": 10
					},
					{
						"name": "ProductAlternateKey",
						"type": "nvarchar"
					},
					{
						"name": "ProductSubcategoryKey",
						"type": "int",
						"precision": 10
					},
					{
						"name": "WeightUnitMeasureCode",
						"type": "nchar"
					},
					{
						"name": "SizeUnitMeasureCode",
						"type": "nchar"
					},
					{
						"name": "EnglishProductName",
						"type": "nvarchar"
					},
					{
						"name": "SpanishProductName",
						"type": "nvarchar"
					},
					{
						"name": "FrenchProductName",
						"type": "nvarchar"
					},
					{
						"name": "StandardCost",
						"type": "money",
						"precision": 19,
						"scale": 4
					},
					{
						"name": "FinishedGoodsFlag",
						"type": "bit"
					},
					{
						"name": "Color",
						"type": "nvarchar"
					},
					{
						"name": "SafetyStockLevel",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "ReorderPoint",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "ListPrice",
						"type": "money",
						"precision": 19,
						"scale": 4
					},
					{
						"name": "Size",
						"type": "nvarchar"
					},
					{
						"name": "SizeRange",
						"type": "nvarchar"
					},
					{
						"name": "Weight",
						"type": "float",
						"precision": 15
					},
					{
						"name": "DaysToManufacture",
						"type": "int",
						"precision": 10
					},
					{
						"name": "ProductLine",
						"type": "nchar"
					},
					{
						"name": "DealerPrice",
						"type": "money",
						"precision": 19,
						"scale": 4
					},
					{
						"name": "Class",
						"type": "nchar"
					},
					{
						"name": "Style",
						"type": "nchar"
					},
					{
						"name": "ModelName",
						"type": "nvarchar"
					},
					{
						"name": "LargePhoto",
						"type": "varbinary"
					},
					{
						"name": "EnglishDescription",
						"type": "nvarchar"
					},
					{
						"name": "FrenchDescription",
						"type": "nvarchar"
					},
					{
						"name": "ChineseDescription",
						"type": "nvarchar"
					},
					{
						"name": "ArabicDescription",
						"type": "nvarchar"
					},
					{
						"name": "HebrewDescription",
						"type": "nvarchar"
					},
					{
						"name": "ThaiDescription",
						"type": "nvarchar"
					},
					{
						"name": "GermanDescription",
						"type": "nvarchar"
					},
					{
						"name": "JapaneseDescription",
						"type": "nvarchar"
					},
					{
						"name": "TurkishDescription",
						"type": "nvarchar"
					},
					{
						"name": "StartDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "EndDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "Status",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "DimProduct"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DS_MigMultipleTables')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "LS_LOCALSQL",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"paramTablename": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@split(dataset().paramTablename,'.')[0]",
						"type": "Expression"
					},
					"table": {
						"value": "@split(dataset().paramTablename,'.')[1]",
						"type": "Expression"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DF001Intro')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DS_OrdersNew",
								"type": "DatasetReference"
							},
							"name": "ReadCSV"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DS_DFSqlSink",
								"type": "DatasetReference"
							},
							"name": "SinkTest"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          OrderDate as date 'dd-mm-yyyy',",
						"          ProductKey as short,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as double,",
						"          TaxAmt as double",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> ReadCSV",
						"ReadCSV sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkTest"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFConditionalSplit')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ConditionalSplitSource",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ConditionalSplitIndiaSink",
								"type": "DatasetReference"
							},
							"name": "ConditionalSplitIndiaSink"
						},
						{
							"dataset": {
								"referenceName": "ConditionalSplitFranceSink",
								"type": "DatasetReference"
							},
							"name": "ConditionalSplitFranceSink"
						}
					],
					"transformations": [
						{
							"name": "ConditionalSplitonCountry"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as string,",
						"          ProductKey as string,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as string,",
						"          UnitPrice as string,",
						"          OrderQuantity as string,",
						"          TaxAmt as string,",
						"          TotalProductCost as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source1 split(Country=='France',",
						"     Country=='India',",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> ConditionalSplitonCountry@(France, India)",
						"ConditionalSplitonCountry@France sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> ConditionalSplitIndiaSink",
						"ConditionalSplitonCountry@India sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> ConditionalSplitFranceSink"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFEXISTTransformation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "JOINTransformationSalesDB",
								"type": "DatasetReference"
							},
							"name": "SalesJOINTransformationSource"
						},
						{
							"dataset": {
								"referenceName": "ProductsJOINTransformation",
								"type": "DatasetReference"
							},
							"name": "ProductsJOINTransformation"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DFExistTransformationSink",
								"type": "DatasetReference"
							},
							"name": "DFExistTransformationSink"
						}
					],
					"transformations": [
						{
							"name": "exists1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ProductKey as string,",
						"          CustomerKey as string,",
						"          SalesAmount as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> SalesJOINTransformationSource",
						"source(output(",
						"          ProductKey as string,",
						"          EnglishProductName as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> ProductsJOINTransformation",
						"SalesJOINTransformationSource, ProductsJOINTransformation exists(SalesJOINTransformationSource@ProductKey == ProductsJOINTransformation@ProductKey,",
						"     negate:false,",
						"     broadcast: 'auto')~> exists1",
						"exists1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> DFExistTransformationSink"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFPivotTransformation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DFSourceDSPivotTransformation",
								"type": "DatasetReference"
							},
							"name": "DFSourcePivotTransformation"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DFSinkSQLDBPivotTransformation",
								"type": "DatasetReference"
							},
							"name": "DFSinkPivotTransformation"
						}
					],
					"transformations": [
						{
							"name": "PivotTransformation"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as string,",
						"          ProductKey as string,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as double,",
						"          UnitPrice as double,",
						"          OrderQuantity as double,",
						"          TaxAmt as double,",
						"          TotalProductCost as double",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> DFSourcePivotTransformation",
						"DFSourcePivotTransformation pivot(groupBy(EnglishProductName),",
						"     pivotBy(Country),",
						"     {} = sum(SalesAmount),",
						"     columnNaming: '$V$N',",
						"     lateral: true,",
						"     partitionBy('hash', 1)) ~> PivotTransformation",
						"PivotTransformation sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     recreate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> DFSinkPivotTransformation"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFRankTransformation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DSRankTransformation",
								"type": "DatasetReference"
							},
							"name": "SourceRankTransformation"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DSSinkRankTransformation",
								"type": "DatasetReference"
							},
							"name": "DFSinkRankTransformation"
						}
					],
					"transformations": [
						{
							"name": "RankTransformation"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EnglishProductName as string,",
						"          SalesAmount as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> SourceRankTransformation",
						"SourceRankTransformation rank(desc(SalesAmount, true),",
						"     output(RankColumn as long),",
						"     dense: true) ~> RankTransformation",
						"RankTransformation sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> DFSinkRankTransformation"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFSource_OrdersCSV_TemplateDF')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DSDeriveColumn",
								"type": "DatasetReference"
							},
							"name": "SourceOrdersCSV"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkDeriveColumn",
								"type": "DatasetReference"
							},
							"name": "SinkSQLDB"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as date 'yyyy-MM-dd',",
						"          ProductKey as string,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as string,",
						"          UnitPrice as string,",
						"          OrderQuantity as string,",
						"          TaxAmt as string,",
						"          TotalProductCost as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionBy('hash', 1)) ~> SourceOrdersCSV",
						"SourceOrdersCSV derive(Year = year(OrderDate),",
						"          Month = month(OrderDate),",
						"          Day = dayOfMonth(OrderDate),",
						"          MonthName = toString(OrderDate, 'MMM'),",
						"     partitionBy('hash', 1)) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkSQLDB"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DFTransformationCast')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DSTransformationCAST",
								"type": "DatasetReference"
							},
							"name": "TransformationCast"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLDB",
								"type": "DatasetReference"
							},
							"name": "SinkCast"
						}
					],
					"transformations": [
						{
							"name": "CastTransform"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as string,",
						"          ProductKey as string,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as string,",
						"          UnitPrice as string,",
						"          OrderQuantity as string,",
						"          TaxAmt as string,",
						"          TotalProductCost as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionBy('hash', 1)) ~> TransformationCast",
						"TransformationCast cast(output(",
						"          OrderDate as date 'yyyy-MM-dd',",
						"          ProductKey as short,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as double,",
						"          TaxAmt as double",
						"     ),",
						"     errors: true) ~> CastTransform",
						"CastTransform sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkCast"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DS_SelectSink')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DS_OrdersNew",
								"type": "DatasetReference"
							},
							"name": "DSCSV"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DS_SelectSink",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "Thisiscrazy"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as date 'dd-MM-yyyy',",
						"          ProductKey as short,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as double,",
						"          TaxAmt as double",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> DSCSV",
						"DSCSV select(mapColumn(",
						"          OrderDateWOW = OrderDate,",
						"          CountryAMAZING = Country,",
						"          EnglishProductNameWTF = EnglishProductName,",
						"          SalesAmountDANG = SalesAmount",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> Thisiscrazy",
						"Thisiscrazy sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LookupTransformation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DSLookupTransformationSource1",
								"type": "DatasetReference"
							},
							"name": "LookupTransformationSource1"
						},
						{
							"dataset": {
								"referenceName": "LookupTransformationSource2",
								"type": "DatasetReference"
							},
							"name": "LookupTransformationSource2"
						},
						{
							"dataset": {
								"referenceName": "DSLookupTransformation",
								"type": "DatasetReference"
							},
							"name": "LookupTransformationSource3"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SqlSInkDBLookupTransformation",
								"type": "DatasetReference"
							},
							"name": "LookupTransformationSQLSINK"
						}
					],
					"transformations": [
						{
							"name": "LookupTransformation"
						},
						{
							"name": "LookupCustomers"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ProductKey as string,",
						"          CustomerKey as integer,",
						"          SalesAmount as double",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> LookupTransformationSource1",
						"source(output(",
						"          ProductKey as string,",
						"          EnglishProductName as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> LookupTransformationSource2",
						"source(output(",
						"          CustomerKey as integer,",
						"          FullName as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> LookupTransformationSource3",
						"LookupTransformationSource1, LookupTransformationSource2 lookup(LookupTransformationSource1@ProductKey == LookupTransformationSource2@ProductKey,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> LookupTransformation",
						"LookupTransformation, LookupTransformationSource3 lookup(LookupTransformationSource1@CustomerKey == LookupTransformationSource3@CustomerKey,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> LookupCustomers",
						"LookupCustomers sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     recreate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          ProductKey = LookupTransformationSource1@ProductKey,",
						"          CustomerKey = LookupTransformationSource1@CustomerKey,",
						"          SalesAmount,",
						"          EnglishProductName,",
						"          FullName",
						"     )) ~> LookupTransformationSQLSINK"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TRANSFORMaggregate')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DSTRANSFORMaggregate",
								"type": "DatasetReference"
							},
							"name": "SourceTRANSFORMaggregate"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TRANSFORMaggregatesqlsink",
								"type": "DatasetReference"
							},
							"name": "TRANSFORMaggregatesink"
						}
					],
					"transformations": [
						{
							"name": "TRANSFORMaggregate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as date 'yyyy-MM-dd',",
						"          ProductKey as string,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as double '000,000,000.000',",
						"          UnitPrice as double,",
						"          OrderQuantity as integer,",
						"          TaxAmt as long,",
						"          TotalProductCost as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> SourceTRANSFORMaggregate",
						"SourceTRANSFORMaggregate aggregate(groupBy(Country),",
						"     TotalSalesAggregate = sum(SalesAmount),",
						"     partitionBy('hash', 1)) ~> TRANSFORMaggregate",
						"TRANSFORMaggregate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> TRANSFORMaggregatesink"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Transform PARSE')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TransformPARSE",
								"type": "DatasetReference"
							},
							"name": "SourceTransformPARSE"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "CosmosDbNoSqlContainer1",
								"type": "DatasetReference"
							},
							"name": "sinkazurecosmosdbparse"
						}
					],
					"transformations": [
						{
							"name": "TransformPARSEorder"
						},
						{
							"name": "TransformPARSEbatch"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderId as integer,",
						"          OrderDate as string,",
						"          OrderDetails as string,",
						"          BatchDetails as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionBy('hash', 1)) ~> SourceTransformPARSE",
						"SourceTransformPARSE parse(OrderDet = OrderDetails ? (Item as string,",
						"          Qty as integer,",
						"          Price as string),",
						"     partitionBy('hash', 1),",
						"     format: 'delimited',",
						"     columnNamesAsHeader: false,",
						"     columnDelimiter: '|',",
						"     nullValue: '') ~> TransformPARSEorder",
						"TransformPARSEorder parse(BatchDET = BatchDetails ? (batchid as string,",
						"          site as string),",
						"     format: 'delimited',",
						"     columnNamesAsHeader: false,",
						"     columnDelimiter: ':',",
						"     nullValue: '') ~> TransformPARSEbatch",
						"TransformPARSEbatch sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'document',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          OrderId,",
						"          OrderDate,",
						"          Item = OrderDet.Item,",
						"          site = BatchDET.site,",
						"          Qty = OrderDet.Qty,",
						"          Price = OrderDet.Price",
						"     )) ~> sinkazurecosmosdbparse"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TransformStringify')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TransformStringifyJSONDS",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TransformStringify",
								"type": "DatasetReference"
							},
							"name": "TransformStringifySINK"
						}
					],
					"transformations": [
						{
							"name": "TransformStringify"
						}
					],
					"scriptLines": [
						"source(output(",
						"          empid as integer,",
						"          empname as string,",
						"          salary as integer,",
						"          phone as (mobile as integer, home as integer)[]",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'arrayOfDocuments') ~> source1",
						"source1 stringify(phone = phone ? string,",
						"     format: 'json') ~> TransformStringify",
						"TransformStringify sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          {10} as string,",
						"          {11} as string,",
						"          Northwest as string,",
						"          {United States} as string,",
						"          {North America} as string",
						"     ),",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> TransformStringifySINK"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/UNPIVOT')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DFSinkSQLDBPivotTransformation",
								"type": "DatasetReference"
							},
							"name": "SourceUnpivotTransformation"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DSSqlSinkUnpivotTransformation",
								"type": "DatasetReference"
							},
							"name": "SinkUnpivotTransformation"
						}
					],
					"transformations": [
						{
							"name": "UnpivotTransformation"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EnglishProductName as string,",
						"          Australia as double,",
						"          Canada as double,",
						"          France as double,",
						"          Germany as double,",
						"          India as double,",
						"          Italy as double,",
						"          {United States} as double",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table',",
						"     partitionBy('hash', 1)) ~> SourceUnpivotTransformation",
						"SourceUnpivotTransformation unpivot(output(",
						"          Country as string,",
						"          {Sales Amount} as double",
						"     ),",
						"     ungroupBy(EnglishProductName),",
						"     lateral: true,",
						"     ignoreNullPivots: true) ~> UnpivotTransformation",
						"UnpivotTransformation sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkUnpivotTransformation"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "LInk",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DFFilterSInk",
								"type": "DatasetReference"
							},
							"name": "DFFILTERSink"
						}
					],
					"transformations": [
						{
							"name": "Filter"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as date 'yyyy-MM-dd',",
						"          ProductKey as string,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as string,",
						"          UnitPrice as string,",
						"          OrderQuantity as string,",
						"          TaxAmt as float,",
						"          TotalProductCost as float",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionBy('hash', 1)) ~> source1",
						"source1 filter(Country=='India') ~> Filter",
						"Filter sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> DFFILTERSink"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrdersJsonTransformFLATTEN",
								"type": "DatasetReference"
							},
							"name": "ReadJsonTransformFLATTEN"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureSQLDFSinkFlatten",
								"type": "DatasetReference"
							},
							"name": "DFSinkFlatten"
						}
					],
					"transformations": [
						{
							"name": "TransformFLATTEN"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderId as integer,",
						"          OrderDate as string,",
						"          Items as string[]",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'arrayOfDocuments') ~> ReadJsonTransformFLATTEN",
						"ReadJsonTransformFLATTEN foldDown(unroll(Items),",
						"     mapColumn(",
						"          OrderId,",
						"          OrderDate,",
						"          Items",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> TransformFLATTEN",
						"TransformFLATTEN sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> DFSinkFlatten"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dfWindowTransformation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DFWindowTransformationSOURCE",
								"type": "DatasetReference"
							},
							"name": "dfsourceWindowTransformation"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DFDSSINKWindowTransformation",
								"type": "DatasetReference"
							},
							"name": "dfSINKWindowTransformation"
						}
					],
					"transformations": [
						{
							"name": "WindowTransformation"
						},
						{
							"name": "AGGREGATE"
						}
					],
					"scriptLines": [
						"source(output(",
						"          OrderDate as date,",
						"          ProductKey as short,",
						"          Country as string,",
						"          EnglishProductName as string,",
						"          SalesAmount as double,",
						"          UnitPrice as double,",
						"          OrderQuantity as boolean,",
						"          TaxAmt as double,",
						"          TotalProductCost as double",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> dfsourceWindowTransformation",
						"AGGREGATE window(over(orderyear = year(OrderDate),",
						"          OrderMonth = month(OrderDate)),",
						"     asc(OrderDate, true),",
						"     {Cumulative Sales} = sum({TOTAL SALES}),",
						"     partitionBy('hash', 1)) ~> WindowTransformation",
						"dfsourceWindowTransformation aggregate(groupBy(OrderDate),",
						"     {TOTAL SALES} = sum(SalesAmount)) ~> AGGREGATE",
						"WindowTransformation sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> dfSINKWindowTransformation"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/sink')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DS036UNIONTransformation",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "036UNIONTransformationSource2",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "DS036UNIONTransformation",
								"type": "DatasetReference"
							},
							"name": "source3"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "UNIONSINK",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "union1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EMPID as short,",
						"          EMPNAME as string,",
						"          SALARY as integer,",
						"          Month as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source(output(",
						"          EMPLOYEENAME as short,",
						"          EMPLOYENAME as string,",
						"          EMPSALARY as integer,",
						"          Monthname as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source2",
						"source(output(",
						"          EMPID as short,",
						"          EMPNAME as string,",
						"          SALARY as integer,",
						"          Month as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source3",
						"source1, source2, source3 union(byName: false,",
						"     partitionBy('hash', 1))~> union1",
						"union1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/022AOneFileIntoMultiFiles')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Get Regions",
						"type": "GetMetadata",
						"dependsOn": [
							{
								"activity": "Truncate Table",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "DS_CountriesFolder",
								"type": "DatasetReference",
								"parameters": {}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "DelimitedTextReadSettings"
							}
						}
					},
					{
						"name": "LoopInRegions",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Regions",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Regions').output.childItems",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Set Region",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Region",
										"value": {
											"value": "@item().name",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Execute Pipeline",
									"type": "ExecutePipeline",
									"dependsOn": [
										{
											"activity": "Set Region",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "022BCHILDpipelineCOUNTRY",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"ParamRegion": {
												"value": "@variables('Region')",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					},
					{
						"name": "Truncate Table",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "LS_ASQL",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": "TRUNCATE TABLE INVOICEDATA"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"Region": {
						"type": "String"
					},
					"Country": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ADF Activities"
				},
				"annotations": [],
				"lastPublishTime": "2025-05-27T20:06:32Z"
			},
			"dependsOn": []
		}
	]
}